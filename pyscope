#!/usr/bin/python3

import numpy as np
import matplotlib.pyplot as plt

#from matplotlib.widgets import Slider, Button, RadioButtons

import time

from pysoundcard import *
from pysoundfile import *

#from scipy import *

fig, ax = plt.subplots()
fig.patch.set_facecolor('black')
ax.title.set_color('blue')
ax.patch.set_facecolor('black')
ax.spines['bottom'].set_color('silver')
ax.spines['top'].set_color('silver')
ax.xaxis.label.set_color('gray')
ax.yaxis.label.set_color('gray')
ax.tick_params(axis='x', colors='red')

l, = plt.plot([], lw=.5, color='green') #initialize some space for us to write to
plt.xlabel("time (s)")
plt.ylabel("amplitude")


def bounds(signal):
	if signal.dtype == np.int16:
		return 2**15
	elif signal.dtype == np.uint16:
		return 2**16
	elif signal.dtype == np.float or signal.dtype == np.float32 or signal.dtype == np.float64:
		return 1
	else:  #panic?
		print(signal.dtype)
		return 1 #???

def pysoundcard_callback(in_data, frame_count, time_info, status):
	# pysoundcard is giving 32 channels on my machine??
	# but the upper channels are empty and the lower ones are dupes?
	# weird...
	signal = in_data.mean(axis=1) #sometimes in_data comes with multiple channels. in lieu of knowing what to do with them
	signal/= bounds(signal) #normalize to -1 to 1
	
	print("energy:", abs(signal).sum())

	#import time as _time
	#_time.sleep(.1) # artificially cause underruns
	
	#NB: shadows 'time' module
	time = np.arange(0, len(signal)) / fs #TODO: don't reference a global! #TODO: cache this t
	l.set_data((time, signal))
	
	ax.set_xlim((time[0], time[-1]))
	ax.set_ylim((-1, 1))

	fig.canvas.draw() #This step might be expensive...
	
	return (None, continue_flag)
	#return (np.zeros_like(in_data), continue_flag)

fs = 44100                 #sample rate to open the card at. Your card probably has a fixed set of these.
block_length = fs//(16) #given a known sample rate, defines how long a single window is
#block_length =2000


RUNNING = True
def fix_it():
	"Work around some kind of bug involving overdriving alsa"
	if RUNNING:
		print("Soundcard crashed. resetting:")
		s.stop() #pysoundcard has a state glitch: it demands I stop it before starting it again, even tho is_active() might say False
		s.start()


print("Starting soundcard:")
dev = default_input_device();
dev['input_channels'] = 1; #PortAudio wants everything to have 32 channels by default
api = list(apis())[dev['host_api_index']]
s = Stream(sample_rate=fs, block_length=block_length, input_device=dev, callback=pysoundcard_callback, finished_callback=fix_it, output_device=False)
plt.title("pyscope: API '%s' device '%s'" % (api['name'], dev['name']))
s.start()

# fuck ..there's no way to display the matplotlib GUI and spin in a readloop in the same thread
from threading import Thread

plt.show()
RUNNING = False
